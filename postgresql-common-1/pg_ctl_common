#!/usr/bin/perl 
#
#  pg_ctl_common 
#
#  Script to start multiple PostgreSQL postmasters according to the
#  configuration
#

use English;
use strict;
use vars qw($opt_c $opt_f $opt_v $opt_x);
use Getopt::Std;

die "Syntax error\n" unless getopts('c:f:vx:');

my $ix = 0;
my $action = "";
my $cluster;
my $wanted_version;
my $mode;
my $silent = ! defined $opt_v;

if ( defined $opt_c && $opt_c ne "" ) {
	$cluster = $opt_c;
}

if ( defined $opt_x && $opt_x ne "" ) {
	# Add supported versions to the next line
	if ($opt_x eq "8.0" || $opt_x eq "7.4") {
		$wanted_version = $opt_x;
	}
}

die "You must run pg_ctl_common as root\n" unless $UID == 0;

$action = $ARGV[0] unless ! defined $ARGV[0];

if ($action eq "start" || $action eq "reload" || $action eq "status") {
	print "Action = $action\n" unless $silent;
} elsif ($action eq "stop" || $action eq "restart") {
	if ($ARGV[$ix++] eq "-m") {
		$mode = $ARGV[$ix];
	} else {
		$mode = "fast";
	}
	print "Action = $action; mode = $mode\n" unless $silent;
} else {
	print <STDOUT>, "Syntax: pg_ctl_common [-c cluster] [-f cluster_file]  start|stop|restart|reload|status\n";
	exit 1;
}

my ($clname, $status, $owner, $version, $port, $path);

my $portfile = "/etc/postgresql/cluster_ports";
$portfile = $opt_f unless ! defined $opt_f;
open CLUSTER_PORTS, $portfile or die "Cannot open $portfile";

while (<CLUSTER_PORTS>) {
	if (! m/^\s*(#.*|)$/) {
		($clname, $status, $owner, $version, $port, $path) = split /\s\s*/, $_;
		printf "Cluster: %s; Status: %s; Owner: %s; Version: %s; Port: %s; Path: %s\n", $clname, $status, $owner, $version, $port, $path unless $silent;
		if ((! defined $cluster && ! defined $wanted_version) || $cluster eq $clname || $version eq $wanted_version) {
			# check cluster owner
			my ($name, $passwd, $uid, $gid, $quota, $comment, $gcos, $dir, $shell) = getpwnam $owner;
			if ($uid == 0) {
				print <STDERR>, "Cluster ${cluster}'s owner is set to root.\nSkipping cluster\n";
				next;
			}
			
			# check cluster database path and version
			my $version_file = "$path/PG_VERSION";
			my $failed = 0;
			my $msg = "Could not open $version_file\n";
			open PGVERSION, $version_file or $failed = 1;
			if ($failed) {
				print <STDERR>, $msg, "Skipping cluster\n";
				next;
			}
			$msg = "Could not read from $version_file";
			my $dbver;
			read PGVERSION, $dbver, 999 or $failed = 1;
			if ($failed) {
				print <STDERR>, $msg, "Skipping cluster\n";
				next;
			}
			close PGVERSION;
			chomp $dbver;
			if ($version != $dbver) {
				print <STDERR>, "Cluster $cluster specifies Pg version $version, but actual version is $dbver\nSkipping cluster\n";
				next;
			}

			# fork so that we can set $EUID and still continue
			# to be root
			my $childpid = fork();
			if ($childpid == 0) {
				# this is the child process
				# set effective uid to cluster owner
				$EUID = $uid;
				$UID = $uid;
				# set correct port to listen on
				$ENV{PGPORT} = $port;

				# define the command to run
				my ($cmd, $options);
				$cmd = "/usr/lib/postgresql/$version/bin/pg_ctl $action -D $path";
				if ($action eq "start") {
					$options = "-p /usr/lib/postgresql/$version/bin/postmaster ";
				} elsif ($action eq "stop" || $action eq "restart") {
					$options = "-m $mode";
				}
				print "Running command: $cmd $options\n" unless $silent;
				system("$cmd $options");
			} else {
				# parent waits for child to finish, so as not
				# to overload the system
				# [ perhaps we need not wait ]
				print "waiting for process $childpid..." unless $silent;
				waitpid $childpid, 0;
				print "completed\n" unless $silent;
			}
		}
	}
}
