#!/usr/bin/perl -w

# multiversion/cluster aware pg_ctl wrapper; this also supplies the correct
# configuration parameters to 'start', and makes sure that a postmaster really
# stops on 'stop'.
#
# (C) 2005 Martin Pitt <mpitt@debian.org>

use lib '/usr/share/postgresql-common';
use Getopt::Long;
use POSIX qw/setsid setlocale LC_ALL/;
use PgCommon;

# command line options
$setuid = 0;
exit 1 unless GetOptions ("setuid|s" => \$setuid);

if ($#ARGV != 2) {
    print "Usage: $0 [-s] <version> <cluster> <action>\n";
    exit 1;
}

sub autovacuum_start {
    return unless $info{'avac_enable'};

    return if -f $info{'pgdata'}.'/autovacuum.pid';

    my %avac_flags = ('avac_sleep_base' => '-s', 'avac_sleep_scale' => '-S',
                      'avac_vac_base'   => '-v', 'avac_vac_scale'   => '-V',
                      'avac_anal_base'  => '-a', 'avac_anal_scale'  => '-A',
                      'avac_log' => '-L');

    @options = ('-p', $info{'port'}, '-H', get_cluster_socketdir($version, $ARGV[1]));

    foreach (keys %info) {
	if (my $option = $avac_flags{$_}) {
            push (@options, $option, $info{$_}) if $info{$_};
	}
    }

    if (!($pid = fork())) {
        close $_ for(STDOUT, STDIN, STDERR);
	setsid;
        chdir '/';
        exec $pg_autovacuum, @options;
	exit -1;
    } else {
        if(open my $AVAC_PID, '>', $info{'pgdata'}.'/autovacuum.pid') {
            print $AVAC_PID "$pid\n";
            close $AVAC_PID;
        }
        exit 0;
    }
}

sub autovacuum_stop {
    return unless ($info{'avac_enable'});

    if (open my $AVAC_PID, $info{'pgdata'}.'/autovacuum.pid') {
        $pid = <$AVAC_PID>;
        close $AVAC_PID;
    }

    kill ('TERM', $pid) if ($pid);
    unlink $info{'pgdata'}.'/autovacuum.pid';
}

sub autovacuum_restart {
    if (-f $info{'pgdata'}.'/autovacuum.pid') {
        autovacuum_stop;
        autovacuum_start;
    }
}

sub start {
    my $cdir = $info{'configdir'};

    # get locale used by initdb
    $pg_controldata = get_program_path 'pg_controldata', $version;
    open (CTRL, '-|', $pg_controldata, $info{'pgdata'}) or 
	error ("Could not start $pg_controldata");
    my $locale = '';
    while (<CTRL>) {
	if (/^LC_CTYPE:\s*(\S+)\s*$/) {
	    $locale = $1;
	    last;
	}
    }
    close CTRL;
    $locale or error ('Could not parse locale out of pg_controldata output');

    # check validity of locale
    unless (setlocale (LC_ALL, $locale)) {
	error ("The server must be started under the locale $locale which does not exist any more.")
    }

    # set locale for the postmaster
    $ENV{'LC_ALL'} = $ENV{'LANG'} = $locale;

    @options = ($pg_ctl, 'start', '-D', $info{'pgdata'},'-l', $info{'logfile'}, '-s');

    # versions 8.0+ support configurable conffile locations
    if ($version >= 8) {
	push @options, '-o';
        push @options, "-c config_file=\"$cdir/postgresql.conf\" -c hba_file=\"$cdir/pg_hba.conf\" -c ident_file=\"$cdir/pg_ident.conf\""; 
    }

    system $pg_ctl @options;

    unless($?) {
	sleep 3;
	autovacuum_start;
    }
}

sub stop {
    autovacuum_stop;

    if (!fork()) {
        close STDOUT;
        exec $pg_ctl, '-D', $info{'pgdata'}, '-s', '-w', '-m', 'fast', 'stop';
    } else {
        wait;
    }

    # try harder if "fast" mode does not work
    if (-f $info{'pgdata'}.'/postmaster.pid') {
        print "(does not shutdown gracefully, now stopping immediately)";
        system $pg_ctl, '-D', $info{'pgdata'}, '-s', '-w', '-m', 'immediate', 'stop';
    }

    # if that still not helps, use the big hammer
    if (-f $info{'pgdata'}.'/postmaster.pid') {
        print "(does not shutdown, killing the process)";
        if (open FPID, $info{'pgdata'}.'/postmaster.pid') {
            $pid = <FPID>;
            close FPID;
        }
        kill (9, $pid) if $pid;
        unlink $info{'pgdata'}.'/postmaster.pid';
    }
}

sub restart {
    stop if $info{'running'};
    start;
}

sub reload {
    exec $pg_ctl, '-D', $info{'pgdata'}, '-s', 'reload';
}

#
# main
#

$version = $ARGV[0];
%info = cluster_info ($version, $ARGV[1]);

error "specified cluster does not exist" unless $info{'pgdata'};

if ($setuid) {
    my $groups = $info{'ownergid'};
    $groups .= " $groups"; # first additional group

    # check whether owner is in the shadow group, and keep shadow privileges in
    # this case; this is a poor workaround for the lack of initgroups().
    my @shadowmembers = split /\s+/, ((getgrnam 'shadow')[3]);
    for my $m (@shadowmembers) {
	my $mid = getpwnam $m;
	if ($mid == $info{'owneruid'}) {
	    $groups .= ' ' . (getgrnam 'shadow');
	    last;
	}
    }

    $( = $) = $groups;
    $< = $> = $info{'owneruid'};
}

if( $> != $info{'owneruid'} ) {
    error 'You must run this program as the cluster owner ('.
        (getpwuid $info{'owneruid'})[0].')';
}

$pg_ctl = get_program_path 'pg_ctl', $ARGV[0];
$pg_autovacuum = get_program_path 'pg_autovacuum', $ARGV[0];

%actions = ('start' => \&start, 'stop' => \&stop, 'reload' => \&reload,
            'restart' => \&restart, 'status' => \&status,
            'autovac-start' => \&autovacuum_start,
            'autovac-stop' => \&autovacuum_stop,
            'autovac-restart' => \&autovacuum_restart);

if ($actions{$ARGV[2]}) {
    $actions{$ARGV[2]}->();
} else {
    error 'Error: invalid action (must be one of: '. 
        (join ', ', keys %actions);
}

__END__

=head1 NAME

pg_ctlcluster - start/stop/restart/reload a PostgreSQL cluster

=head1 SYNOPSIS

B<pg_ctlcluster> [B<--setuid>|B<-s>] I<cluster-version> I<cluster-name> I<action>

where I<action> = B<start>|B<stop>|B<restart>|B<reload>|B<autovac-start>|B<autovac-stop>|B<autovac-restart>

=head1 DESCRIPTION

This program controls the B<postmaster> server for a particular cluster. It
essentially wraps the B<pg_ctl> command. It determines the cluster version and
data path and calls the right version of B<pg_ctl> with appropriate
configuration parameters and paths.

You have to start this program as the user who owns the database cluster. If
you start B<pg_ctlcluster> as root, you can also use the option
B<--setuid>/B<-s> to automatically set the user and group id to the cluster
owner.

In B<start> mode, a log file for this specific cluster is created if it does
not exist yet (by default,
B</var/log/postgresql/postgresql->I<cluster-version>B<->I<cluster-name>B<.log>),
and a PostreSQL server process (B<postmaster>) is started on it. If the package
B<postgresql-contrib->I<version> is installed, a B<pg_autovacuum> process is
started as well (unless this gets disabled in
B</etc/postgresql-common/autovacuum.conf> or a cluster-specific
B<autovacuum.conf> file).

B<stop> stops the B<postmaster> server (and B<pg_autovacuum>, if running) of
the given cluster with increasing force. Initially, the B<fast> mode is used
which rolls back all active transactions and thus shuts down cleanly. If that
does not work, shutdown is attempted again in B<immediate> mode, which can
leave the cluster in an inconsistent state and thus will lead to a recovery run
at the next start. If this still does not help, the B<postmaster> process is
killed.

B<restart> stops the server if it is running and starts it (again). If
B<pg_autovacuum> is running on the server, it is restarted as well.

B<reload> will cause the configuration files to be re-read without a full
shutdown of the server.

B<autovac-start> starts a B<pg_autovacuum> process for an already running
cluster. This normally happens automatically along with B<start>.

B<autovac-stop> stops the B<pg_autovacuum> process for a running cluster. This
normally happens automatically along with B<stop>.

B<autovac-restart> restarts a B<pg_autovacuum> process for an already running
cluster. This normally happens automatically along with B<restart>.

=head1 SEE ALSO

L<pg_ctl(1)>, L<pg_wrapper(1)>, L<pg_lsclusters(1)>

=head1 AUTHOR

Martin Pitt L<E<lt>mpitt@debian.orgE<gt>>

